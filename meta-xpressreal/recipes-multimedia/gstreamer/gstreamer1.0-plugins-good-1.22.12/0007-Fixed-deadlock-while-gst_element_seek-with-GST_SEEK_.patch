From 39720e0788fd26ae91cdf81def4d93128734ed85 Mon Sep 17 00:00:00 2001
From: "joshua.yang" <joshua.yang@realtek.com>
Date: Thu, 20 Mar 2025 16:33:21 +0800
Subject: [PATCH 1/1] Fixed deadlock while gst_element_seek with GST_SEEK_FLAG_FLUSH
Upstream-Status: Inappropriate [rtk specific]

[What] Pipeline got stuck while using gst_element_seek() with GST_SEEK_FLAG_FLUSH
[Why] There is a deadlock in gst_v4l2_buffer_pool_flush() and gst_v4l2_buffer_pool_qbuf(). Both of them hold the same GST_OBJECT_LOCK (pool).
[How] Don't lock again while calling gst_v4l2_buffer_pool_qbuf in gst_v4l2_buffer_pool_flush.
---
 sys/v4l2/gstv4l2bufferpool.c | 18 +++++++++++++-----
 1 file changed, 13 insertions(+), 5 deletions(-)

diff --git a/sys/v4l2/gstv4l2bufferpool.c b/sys/v4l2/gstv4l2bufferpool.c
index 58c2099..b05c790 100644
--- a/sys/v4l2/gstv4l2bufferpool.c
+++ b/sys/v4l2/gstv4l2bufferpool.c
@@ -1148,8 +1148,12 @@ gst_v4l2_buffer_pool_qbuf (GstV4l2BufferPool * pool, GstBuffer * buf,
   const GstV4l2Object *obj = pool->obj;
   gint old_buffer_state;
   gint index;
+  gboolean lock = FALSE;
 
-  GST_OBJECT_LOCK (pool);
+  if (pool->streaming == TRUE) {
+    GST_OBJECT_LOCK (pool);
+    lock = TRUE;
+  }
 
   index = group->buffer.index;
 
@@ -1200,14 +1204,16 @@ gst_v4l2_buffer_pool_qbuf (GstV4l2BufferPool * pool, GstBuffer * buf,
 
   pool->empty = FALSE;
   g_cond_signal (&pool->empty_cond);
-  GST_OBJECT_UNLOCK (pool);
+  if (lock)
+    GST_OBJECT_UNLOCK (pool);
 
   return GST_FLOW_OK;
 
 already_queued:
   {
     GST_ERROR_OBJECT (pool, "the buffer %i was already queued", index);
-    GST_OBJECT_UNLOCK (pool);
+    if (lock)
+      GST_OBJECT_UNLOCK (pool);
     return GST_FLOW_ERROR;
   }
 was_orphaned:
@@ -1215,7 +1221,8 @@ was_orphaned:
     GST_DEBUG_OBJECT (pool, "pool was orphaned, not queuing back buffer.");
     GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_TAG_MEMORY);
     g_atomic_int_and (&pool->buffer_state[index], ~BUFFER_STATE_QUEUED);
-    GST_OBJECT_UNLOCK (pool);
+    if (lock)
+      GST_OBJECT_UNLOCK (pool);
     return GST_FLOW_FLUSHING;
   }
 queue_failed:
@@ -1226,7 +1233,8 @@ queue_failed:
     g_atomic_int_add (&pool->num_queued, -1);
     pool->buffers[index] = NULL;
     g_atomic_int_and (&pool->buffer_state[index], ~BUFFER_STATE_QUEUED);
-    GST_OBJECT_UNLOCK (pool);
+    if (lock)
+      GST_OBJECT_UNLOCK (pool);
     return GST_FLOW_ERROR;
   }
 }
-- 
2.34.1

