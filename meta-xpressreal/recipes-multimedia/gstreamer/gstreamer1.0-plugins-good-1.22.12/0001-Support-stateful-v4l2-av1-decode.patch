From 4a9ea77d9b15aa0d90b81c3bb1c3d9241a8dfdbe Mon Sep 17 00:00:00 2001
From: "joshua.yang" <joshua.yang@realtek.com>
Date: Wed, 11 Dec 2024 15:30:59 +0800
Subject: [PATCH 1/1] Support stateful v4l2 av1 decode

Upstream-Status: Inappropriate [rtk specific]
---
 sys/v4l2/ext/v4l2-controls.h |  82 +++++++++++++++
 sys/v4l2/ext/videodev2.h     |   1 +
 sys/v4l2/gstv4l2av1codec.c   | 192 +++++++++++++++++++++++++++++++++++
 sys/v4l2/gstv4l2av1codec.h   |  32 ++++++
 sys/v4l2/gstv4l2object.c     |   6 ++
 sys/v4l2/gstv4l2videodec.c   |   6 +-
 sys/v4l2/meson.build         |   1 +
 7 files changed, 319 insertions(+), 1 deletion(-)
 create mode 100644 sys/v4l2/gstv4l2av1codec.c
 create mode 100644 sys/v4l2/gstv4l2av1codec.h

diff --git a/sys/v4l2/ext/v4l2-controls.h b/sys/v4l2/ext/v4l2-controls.h
index af15f01..40a2d65 100644
--- a/sys/v4l2/ext/v4l2-controls.h
+++ b/sys/v4l2/ext/v4l2-controls.h
@@ -812,6 +812,88 @@ enum v4l2_mpeg_video_frame_skip_mode {
 #define V4L2_CID_MPEG_VIDEO_DEC_DISPLAY_DELAY		(V4L2_CID_CODEC_BASE + 653)
 #define V4L2_CID_MPEG_VIDEO_DEC_DISPLAY_DELAY_ENABLE	(V4L2_CID_CODEC_BASE + 654)
 
+#define V4L2_CID_MPEG_VIDEO_AV1_PROFILE (V4L2_CID_CODEC_BASE + 655)
+/**
+ * enum v4l2_mpeg_video_av1_profile - AV1 profiles
+ *
+ * @V4L2_MPEG_VIDEO_AV1_PROFILE_MAIN: compliant decoders must be able to decode
+ * streams with seq_profile equal to 0.
+ * @V4L2_MPEG_VIDEO_AV1_PROFILE_HIGH: compliant decoders must be able to decode
+ * streams with seq_profile equal less than or equal to 1.
+ * @V4L2_MPEG_VIDEO_AV1_PROFILE_PROFESSIONAL: compliant decoders must be able to
+ * decode streams with seq_profile less than or equal to 2.
+ *
+ * Conveys the highest profile a decoder can work with.
+ */
+enum v4l2_mpeg_video_av1_profile {
+	V4L2_MPEG_VIDEO_AV1_PROFILE_MAIN = 0,
+	V4L2_MPEG_VIDEO_AV1_PROFILE_HIGH = 1,
+	V4L2_MPEG_VIDEO_AV1_PROFILE_PROFESSIONAL = 2,
+};
+
+#define V4L2_CID_MPEG_VIDEO_AV1_LEVEL (V4L2_CID_CODEC_BASE + 656)
+/**
+ * enum v4l2_mpeg_video_av1_level - AV1 levels
+ *
+ * @V4L2_MPEG_VIDEO_AV1_LEVEL_2_0: Level 2.0.
+ * @V4L2_MPEG_VIDEO_AV1_LEVEL_2_1: Level 2.1.
+ * @V4L2_MPEG_VIDEO_AV1_LEVEL_2_2: Level 2.2.
+ * @V4L2_MPEG_VIDEO_AV1_LEVEL_2_3: Level 2.3.
+ * @V4L2_MPEG_VIDEO_AV1_LEVEL_3_0: Level 3.0.
+ * @V4L2_MPEG_VIDEO_AV1_LEVEL_3_1: Level 3.1.
+ * @V4L2_MPEG_VIDEO_AV1_LEVEL_3_2: Level 3.2.
+ * @V4L2_MPEG_VIDEO_AV1_LEVEL_3_3: Level 3.3.
+ * @V4L2_MPEG_VIDEO_AV1_LEVEL_4_0: Level 4.0.
+ * @V4L2_MPEG_VIDEO_AV1_LEVEL_4_1: Level 4.1.
+ * @V4L2_MPEG_VIDEO_AV1_LEVEL_4_2: Level 4.2.
+ * @V4L2_MPEG_VIDEO_AV1_LEVEL_4_3: Level 4.3.
+ * @V4L2_MPEG_VIDEO_AV1_LEVEL_5_0: Level 5.0.
+ * @V4L2_MPEG_VIDEO_AV1_LEVEL_5_1: Level 5.1.
+ * @V4L2_MPEG_VIDEO_AV1_LEVEL_5_2: Level 5.2.
+ * @V4L2_MPEG_VIDEO_AV1_LEVEL_5_3: Level 5.3.
+ * @V4L2_MPEG_VIDEO_AV1_LEVEL_6_0: Level 6.0.
+ * @V4L2_MPEG_VIDEO_AV1_LEVEL_6_1: Level 6.1.
+ * @V4L2_MPEG_VIDEO_AV1_LEVEL_6_2: Level 6.2.
+ * @V4L2_MPEG_VIDEO_AV1_LEVEL_6_3: Level 6.3.
+ * @V4L2_MPEG_VIDEO_AV1_LEVEL_7_0: Level 7.0.
+ * @V4L2_MPEG_VIDEO_AV1_LEVEL_7_1: Level 7.1.
+ * @V4L2_MPEG_VIDEO_AV1_LEVEL_7_2: Level 7.2.
+ * @V4L2_MPEG_VIDEO_AV1_LEVEL_7_3: Level 7.3.
+ *
+ * Conveys the highest level a decoder can work with.
+ */
+enum v4l2_mpeg_video_av1_level {
+	V4L2_MPEG_VIDEO_AV1_LEVEL_2_0 = 0,
+	V4L2_MPEG_VIDEO_AV1_LEVEL_2_1 = 1,
+	V4L2_MPEG_VIDEO_AV1_LEVEL_2_2 = 2,
+	V4L2_MPEG_VIDEO_AV1_LEVEL_2_3 = 3,
+
+	V4L2_MPEG_VIDEO_AV1_LEVEL_3_0 = 4,
+	V4L2_MPEG_VIDEO_AV1_LEVEL_3_1 = 5,
+	V4L2_MPEG_VIDEO_AV1_LEVEL_3_2 = 6,
+	V4L2_MPEG_VIDEO_AV1_LEVEL_3_3 = 7,
+
+	V4L2_MPEG_VIDEO_AV1_LEVEL_4_0 = 8,
+	V4L2_MPEG_VIDEO_AV1_LEVEL_4_1 = 9,
+	V4L2_MPEG_VIDEO_AV1_LEVEL_4_2 = 10,
+	V4L2_MPEG_VIDEO_AV1_LEVEL_4_3 = 11,
+
+	V4L2_MPEG_VIDEO_AV1_LEVEL_5_0 = 12,
+	V4L2_MPEG_VIDEO_AV1_LEVEL_5_1 = 13,
+	V4L2_MPEG_VIDEO_AV1_LEVEL_5_2 = 14,
+	V4L2_MPEG_VIDEO_AV1_LEVEL_5_3 = 15,
+
+	V4L2_MPEG_VIDEO_AV1_LEVEL_6_0 = 16,
+	V4L2_MPEG_VIDEO_AV1_LEVEL_6_1 = 17,
+	V4L2_MPEG_VIDEO_AV1_LEVEL_6_2 = 18,
+	V4L2_MPEG_VIDEO_AV1_LEVEL_6_3 = 19,
+
+	V4L2_MPEG_VIDEO_AV1_LEVEL_7_0 = 20,
+	V4L2_MPEG_VIDEO_AV1_LEVEL_7_1 = 21,
+	V4L2_MPEG_VIDEO_AV1_LEVEL_7_2 = 22,
+	V4L2_MPEG_VIDEO_AV1_LEVEL_7_3 = 23
+};
+
 /*  MPEG-class control IDs specific to the CX2341x driver as defined by V4L2 */
 #define V4L2_CID_CODEC_CX2341X_BASE				(V4L2_CTRL_CLASS_CODEC | 0x1000)
 #define V4L2_CID_MPEG_CX2341X_VIDEO_SPATIAL_FILTER_MODE		(V4L2_CID_CODEC_CX2341X_BASE+0)
diff --git a/sys/v4l2/ext/videodev2.h b/sys/v4l2/ext/videodev2.h
index 16a9494..a940058 100644
--- a/sys/v4l2/ext/videodev2.h
+++ b/sys/v4l2/ext/videodev2.h
@@ -700,6 +700,7 @@ struct v4l2_pix_format {
 #define V4L2_PIX_FMT_VP8_FRAME v4l2_fourcc('V', 'P', '8', 'F') /* VP8 parsed frame */
 #define V4L2_PIX_FMT_VP9      v4l2_fourcc('V', 'P', '9', '0') /* VP9 */
 #define V4L2_PIX_FMT_VP9_FRAME v4l2_fourcc('V', 'P', '9', 'F') /* VP9 parsed frame */
+#define V4L2_PIX_FMT_AV1      v4l2_fourcc('A', 'V', '0', '1') /* AV1 */
 #define V4L2_PIX_FMT_HEVC     v4l2_fourcc('H', 'E', 'V', 'C') /* HEVC aka H.265 */
 #define V4L2_PIX_FMT_FWHT     v4l2_fourcc('F', 'W', 'H', 'T') /* Fast Walsh Hadamard Transform (vicodec) */
 #define V4L2_PIX_FMT_FWHT_STATELESS     v4l2_fourcc('S', 'F', 'W', 'H') /* Stateless FWHT (vicodec) */
diff --git a/sys/v4l2/gstv4l2av1codec.c b/sys/v4l2/gstv4l2av1codec.c
new file mode 100644
index 0000000..5c78eba
--- /dev/null
+++ b/sys/v4l2/gstv4l2av1codec.c
@@ -0,0 +1,192 @@
+/*
+ * Copyright (C) 2024 Realtek Semiconductor Corp. All rights reserved.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "gstv4l2av1codec.h"
+
+#include <gst/gst.h>
+#include "ext/v4l2-controls.h"
+
+
+static gint
+v4l2_profile_from_string (const gchar * profile)
+{
+  gint v4l2_profile = -1;
+
+  if (g_str_equal (profile, "0"))
+    v4l2_profile = 0;
+  else if (g_str_equal (profile, "1"))
+    v4l2_profile = 1;
+  else if (g_str_equal (profile, "2"))
+    v4l2_profile = 2;
+  else
+    GST_WARNING ("Unsupported profile string '%s'", profile);
+
+  return v4l2_profile;
+}
+
+static const gchar *
+v4l2_profile_to_string (gint v4l2_profile)
+{
+  switch (v4l2_profile) {
+    case 0:
+      return "main";
+    case 1:
+      return "high";
+    case 2:
+      return "professional";
+    default:
+      GST_WARNING ("Unsupported V4L2 profile %i", v4l2_profile);
+      break;
+  }
+
+  return NULL;
+}
+
+static gint
+v4l2_level_from_string (const gchar * level)
+{
+  gint v4l2_level = -1;
+
+  if (g_str_equal (level, "2"))
+    v4l2_level = V4L2_MPEG_VIDEO_AV1_LEVEL_2_0;
+  else if (g_str_equal (level, "2.1"))
+    v4l2_level = V4L2_MPEG_VIDEO_AV1_LEVEL_2_1;
+  else if (g_str_equal (level, "2.2"))
+    v4l2_level = V4L2_MPEG_VIDEO_AV1_LEVEL_2_2;
+  else if (g_str_equal (level, "2.3"))
+    v4l2_level = V4L2_MPEG_VIDEO_AV1_LEVEL_2_3;
+  else if (g_str_equal (level, "3"))
+    v4l2_level = V4L2_MPEG_VIDEO_AV1_LEVEL_3_0;
+  else if (g_str_equal (level, "3.1"))
+    v4l2_level = V4L2_MPEG_VIDEO_AV1_LEVEL_3_1;
+  else if (g_str_equal (level, "3.2"))
+    v4l2_level = V4L2_MPEG_VIDEO_AV1_LEVEL_3_2;
+  else if (g_str_equal (level, "3.3"))
+    v4l2_level = V4L2_MPEG_VIDEO_AV1_LEVEL_3_3;
+  else if (g_str_equal (level, "4"))
+    v4l2_level = V4L2_MPEG_VIDEO_AV1_LEVEL_4_0;
+  else if (g_str_equal (level, "4.1"))
+    v4l2_level = V4L2_MPEG_VIDEO_AV1_LEVEL_4_1;
+  else if (g_str_equal (level, "4.2"))
+    v4l2_level = V4L2_MPEG_VIDEO_AV1_LEVEL_4_2;
+  else if (g_str_equal (level, "4.3"))
+    v4l2_level = V4L2_MPEG_VIDEO_AV1_LEVEL_4_3;
+  else if (g_str_equal (level, "5"))
+    v4l2_level = V4L2_MPEG_VIDEO_AV1_LEVEL_5_0;
+  else if (g_str_equal (level, "5.1"))
+    v4l2_level = V4L2_MPEG_VIDEO_AV1_LEVEL_5_1;
+  else if (g_str_equal (level, "5.2"))
+    v4l2_level = V4L2_MPEG_VIDEO_AV1_LEVEL_5_2;
+  else if (g_str_equal (level, "5.3"))
+    v4l2_level = V4L2_MPEG_VIDEO_AV1_LEVEL_5_3;
+  else if (g_str_equal (level, "6"))
+    v4l2_level = V4L2_MPEG_VIDEO_AV1_LEVEL_6_0;
+  else if (g_str_equal (level, "6.1"))
+    v4l2_level = V4L2_MPEG_VIDEO_AV1_LEVEL_6_1;
+  else if (g_str_equal (level, "6.2"))
+    v4l2_level = V4L2_MPEG_VIDEO_AV1_LEVEL_6_2;
+  else if (g_str_equal (level, "6.3"))
+    v4l2_level = V4L2_MPEG_VIDEO_AV1_LEVEL_6_3;
+  else if (g_str_equal (level, "7"))
+    v4l2_level = V4L2_MPEG_VIDEO_AV1_LEVEL_7_0;
+  else if (g_str_equal (level, "7.1"))
+    v4l2_level = V4L2_MPEG_VIDEO_AV1_LEVEL_7_1;
+  else if (g_str_equal (level, "7.2"))
+    v4l2_level = V4L2_MPEG_VIDEO_AV1_LEVEL_7_2;
+  else if (g_str_equal (level, "7.3"))
+    v4l2_level = V4L2_MPEG_VIDEO_AV1_LEVEL_7_3;
+  else
+    GST_WARNING ("Unsupported level '%s'", level);
+
+  return v4l2_level;
+}
+
+static const gchar *
+v4l2_level_to_string (gint v4l2_level)
+{
+  switch (v4l2_level) {
+    case V4L2_MPEG_VIDEO_AV1_LEVEL_2_0:
+      return "2";
+    case V4L2_MPEG_VIDEO_AV1_LEVEL_2_1:
+      return "2.1";
+    case V4L2_MPEG_VIDEO_AV1_LEVEL_2_2:
+      return "2.2";
+    case V4L2_MPEG_VIDEO_AV1_LEVEL_2_3:
+      return "2.3";
+    case V4L2_MPEG_VIDEO_H264_LEVEL_1_3:
+      return "1.3";
+    case V4L2_MPEG_VIDEO_H264_LEVEL_2_0:
+      return "2";
+    case V4L2_MPEG_VIDEO_H264_LEVEL_2_1:
+      return "2.1";
+    case V4L2_MPEG_VIDEO_H264_LEVEL_2_2:
+      return "2.2";
+    case V4L2_MPEG_VIDEO_H264_LEVEL_3_0:
+      return "3";
+    case V4L2_MPEG_VIDEO_H264_LEVEL_3_1:
+      return "3.1";
+    case V4L2_MPEG_VIDEO_H264_LEVEL_3_2:
+      return "3.2";
+    case V4L2_MPEG_VIDEO_H264_LEVEL_4_0:
+      return "4";
+    case V4L2_MPEG_VIDEO_H264_LEVEL_4_1:
+      return "4.1";
+    case V4L2_MPEG_VIDEO_H264_LEVEL_4_2:
+      return "4.2";
+    case V4L2_MPEG_VIDEO_H264_LEVEL_5_0:
+      return "5";
+    case V4L2_MPEG_VIDEO_H264_LEVEL_5_1:
+      return "5.1";
+    case V4L2_MPEG_VIDEO_H264_LEVEL_5_2:
+      return "5.2";
+    case V4L2_MPEG_VIDEO_H264_LEVEL_6_0:
+      return "6";
+    case V4L2_MPEG_VIDEO_H264_LEVEL_6_1:
+      return "6.1";
+    case V4L2_MPEG_VIDEO_H264_LEVEL_6_2:
+      return "6.2";
+    default:
+      GST_WARNING ("Unsupported V4L2 level %i", v4l2_level);
+      break;
+  }
+
+  return NULL;
+}
+
+const GstV4l2Codec *
+gst_v4l2_av1_get_codec (void)
+{
+  static GstV4l2Codec *codec = NULL;
+  if (g_once_init_enter (&codec)) {
+    static GstV4l2Codec c;
+    c.profile_cid = V4L2_CID_MPEG_VIDEO_AV1_PROFILE;
+    c.profile_to_string = v4l2_profile_to_string;
+    c.profile_from_string = v4l2_profile_from_string;
+    c.level_cid = V4L2_CID_MPEG_VIDEO_AV1_LEVEL;
+    c.level_to_string = v4l2_level_to_string;
+    c.level_from_string = v4l2_level_from_string;
+    g_once_init_leave (&codec, &c);
+  }
+  return codec;
+}
diff --git a/sys/v4l2/gstv4l2av1codec.h b/sys/v4l2/gstv4l2av1codec.h
new file mode 100644
index 0000000..5e66fe8
--- /dev/null
+++ b/sys/v4l2/gstv4l2av1codec.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2024 Realtek Semiconductor Corp. All rights reserved.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ *
+ */
+
+#ifndef __GST_V4L2_AV1_CODEC_H__
+#define __GST_V4L2_AV1_CODEC_H__
+
+#include "gstv4l2codec.h"
+
+G_BEGIN_DECLS
+
+const GstV4l2Codec * gst_v4l2_av1_get_codec (void);
+
+G_END_DECLS
+
+#endif
diff --git a/sys/v4l2/gstv4l2object.c b/sys/v4l2/gstv4l2object.c
index c1df2ad..199c5d4 100644
--- a/sys/v4l2/gstv4l2object.c
+++ b/sys/v4l2/gstv4l2object.c
@@ -192,6 +192,7 @@ static const GstV4L2FormatDesc gst_v4l2_formats[] = {
   {V4L2_PIX_FMT_VC1_ANNEX_L, FALSE, GST_V4L2_CODEC},
   {V4L2_PIX_FMT_VP8, FALSE, GST_V4L2_CODEC | GST_V4L2_NO_PARSE},
   {V4L2_PIX_FMT_VP9, FALSE, GST_V4L2_CODEC | GST_V4L2_NO_PARSE},
+  {V4L2_PIX_FMT_AV1, FALSE, GST_V4L2_CODEC | GST_V4L2_NO_PARSE},
 
   /*  Vendor-specific formats   */
   {V4L2_PIX_FMT_WNVA, TRUE, GST_V4L2_CODEC},
@@ -1534,6 +1535,9 @@ gst_v4l2_object_v4l2fourcc_to_bare_struct (guint32 fourcc)
     case V4L2_PIX_FMT_VP9:
       structure = gst_structure_new_empty ("video/x-vp9");
       break;
+    case V4L2_PIX_FMT_AV1:
+      structure = gst_structure_new_empty ("video/x-av1");
+      break;
     case V4L2_PIX_FMT_GREY:    /*  8  Greyscale     */
     case V4L2_PIX_FMT_Y16:
     case V4L2_PIX_FMT_Y16_BE:
@@ -2008,6 +2012,8 @@ gst_v4l2_object_get_caps_info (GstV4l2Object * v4l2object, GstCaps * caps,
       fourcc = V4L2_PIX_FMT_VP8;
     } else if (g_str_equal (mimetype, "video/x-vp9")) {
       fourcc = V4L2_PIX_FMT_VP9;
+    } else if (g_str_equal (mimetype, "video/x-av1")) {
+      fourcc = V4L2_PIX_FMT_AV1;
     } else if (g_str_equal (mimetype, "video/x-bayer")) {
       const gchar *format = gst_structure_get_string (structure, "format");
       if (format) {
diff --git a/sys/v4l2/gstv4l2videodec.c b/sys/v4l2/gstv4l2videodec.c
index c7f39dd..1a11bc7 100644
--- a/sys/v4l2/gstv4l2videodec.c
+++ b/sys/v4l2/gstv4l2videodec.c
@@ -38,6 +38,7 @@
 #include "gstv4l2mpeg4codec.h"
 #include "gstv4l2vp8codec.h"
 #include "gstv4l2vp9codec.h"
+#include "gstv4l2av1codec.h"
 
 #include <string.h>
 #include <glib/gi18n-lib.h>
@@ -928,7 +929,7 @@ gst_v4l2_video_dec_handle_frame (GstVideoDecoder * decoder,
      * we need to send something, otherwise the decoder will refuse to
      * initialize.
      */
-    if (codec_data) {
+    if (codec_data && self->v4l2output->fmtdesc->pixelformat != V4L2_PIX_FMT_AV1) {
       gst_buffer_ref (codec_data);
     } else {
       codec_data = gst_buffer_ref (frame->input_buffer);
@@ -1393,6 +1394,9 @@ G_STMT_START { \
   } else if (gst_structure_has_name (s, "video/x-vp9")) {
     SET_META ("VP9");
     cdata->codec = gst_v4l2_vp9_get_codec ();
+  } else if (gst_structure_has_name (s, "video/x-av1")) {
+    SET_META ("AV1");
+    cdata->codec = gst_v4l2_av1_get_codec ();
   } else if (gst_structure_has_name (s, "video/x-bayer")) {
     SET_META ("BAYER");
   } else if (gst_structure_has_name (s, "video/x-sonix")) {
diff --git a/sys/v4l2/meson.build b/sys/v4l2/meson.build
index 6ece251..d95120a 100644
--- a/sys/v4l2/meson.build
+++ b/sys/v4l2/meson.build
@@ -29,6 +29,7 @@ v4l2_sources = [
   'gstv4l2vp8enc.c',
   'gstv4l2vp9codec.c',
   'gstv4l2vp9enc.c',
+  'gstv4l2av1codec.c',
   'v4l2_calls.c',
   'v4l2-utils.c',
   'tuner.c',
-- 
2.34.1

